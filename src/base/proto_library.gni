# Copyright 2014 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# From chromium third_party/protobuf/proto_library.gni

if (host_os == "win") {
  _host_executable_suffix = ".exe"
} else {
  _host_executable_suffix = ""
}

#_protoc_label = "//third_party/protobuf:protoc($host_toolchain)"
#_protoc_path = get_label_info(_protoc_label, "root_out_dir") + "/protoc" +
#               _host_executable_suffix

_protoc_path = "/usr/local/bin/protoc"

template("proto_library") {
  assert(defined(invoker.sources), "Need sources for proto_library")
  proto_sources = invoker.sources

  generate_cc = true

  if (defined(invoker.generate_descriptor)) {
    generate_descriptor = invoker.generate_descriptor
  } else {
    generate_descriptor = ""
  }

  # exclude_imports is only used for generating the descriptor. Therefore, the
  # check needs to be here to avoid complaints from GN about the unused
  # variable.
  if (generate_descriptor != "") {
    if (defined(invoker.exclude_imports)) {
      exclude_imports = invoker.exclude_imports
    } else {
      exclude_imports = false
    }
  }

  if (defined(invoker.generator_plugin_label)) {
    # Straightforward way to get the name of executable doesn't work because
    # |root_out_dir| and |root_build_dir| may differ in cross-compilation and
    # also Windows executables have .exe at the end.

    plugin_host_label = invoker.generator_plugin_label + "($host_toolchain)"
    plugin_path =
        get_label_info(plugin_host_label, "root_out_dir") + "/" +
        get_label_info(plugin_host_label, "name") + _host_executable_suffix
    generate_with_plugin = true
  } else if (defined(invoker.generator_plugin_script)) {
    plugin_path = invoker.generator_plugin_script
    generate_with_plugin = true
  } else {
    generate_with_plugin = false
  }

  if (generate_with_plugin) {
    if (defined(invoker.generator_plugin_suffix)) {
      generator_plugin_suffixes = [
        "${invoker.generator_plugin_suffix}.h",
        "${invoker.generator_plugin_suffix}.cc",
      ]
    } else {
      generator_plugin_suffixes = invoker.generator_plugin_suffixes
    }
  }

  if (defined(invoker.proto_in_dir)) {
    proto_in_dir = invoker.proto_in_dir
    has_nested_dirs = false
    foreach(proto_source, proto_sources) {
      if (get_path_info(proto_source, "dir") != proto_in_dir) {
        has_nested_dirs = true
      }
    }
  } else {
    proto_in_dir = get_path_info(proto_sources[0], "dir")
    has_nested_dirs = false

    # Sanity check, |proto_in_dir| should be defined to allow sub-directories.
    foreach(proto_source, proto_sources) {
      assert(get_path_info(proto_source, "dir") == proto_in_dir,
             "Please define |proto_in_dir| to allow nested directories.")
    }
  }

  # Avoid absolute path because of the assumption that |proto_in_dir| is
  # relative to the directory of current BUILD.gn file.
  proto_in_dir = rebase_path(proto_in_dir, ".")

  if (defined(invoker.proto_out_dir)) {
    proto_out_dir = invoker.proto_out_dir
  } else {
    # Absolute path to the directory of current BUILD.gn file excluding "//".
    proto_out_dir = rebase_path(".", "//")
    if (proto_in_dir != ".") {
      proto_out_dir += "/$proto_in_dir"
    }
  }

  # We need both absolute path to use in GN statements and a relative one
  # to pass to external script.
  if (generate_cc || generate_with_plugin) {
    cc_out_dir = "$root_gen_dir/" + proto_out_dir
    rel_cc_out_dir = rebase_path(cc_out_dir, root_build_dir)
  }
  if (generate_descriptor != "") {
    descriptor_out =
        "$root_gen_dir/" + proto_out_dir + "/" + generate_descriptor
    rel_descriptor_out = rebase_path(descriptor_out, root_build_dir)
  }

  protos = rebase_path(invoker.sources, proto_in_dir)
  protogens = []
  protogens_cc = []
  protogens_js = []

  # Whether source code bindings should be generated.
  generate_sources = generate_cc || generate_with_plugin

  # Whether library should be generated.
  # Library is not needed when proto_library is used to generate binary descriptor, in which case
  # corresponding library target should be omitted entirely.
  if (defined(invoker.generate_library)) {
    generate_library = invoker.generate_library
  } else {
    generate_library = generate_sources
  }

  # List output files.
  if (generate_sources) {
    foreach(proto, protos) {
      proto_dir = get_path_info(proto, "dir")
      proto_name = get_path_info(proto, "name")
      proto_path = proto_dir + "/" + proto_name

      if (generate_cc) {
        protogens_cc += [
          "$cc_out_dir/$proto_path.pb.h",
          "$cc_out_dir/$proto_path.pb.cc",
        ]
      }
      if (generate_with_plugin) {
        foreach(suffix, generator_plugin_suffixes) {
          protogens_cc += [ "$cc_out_dir/${proto_path}${suffix}" ]
        }
      }
    }
  }

  # If descriptor needs to be generated, it should be added to list of outputs once.
  if (generate_descriptor != "") {
    protogens += [ descriptor_out ]
  }

  action_name = "${target_name}_gen"
  source_set_name = target_name
  javascript_name = "${target_name}_js"

  # Generate protobuf stubs.
  action(action_name) {
    visibility = [
      ":$javascript_name",
      ":$source_set_name",
    ]
    script = "//src/base/protoc_wrapper/protoc_wrapper.py"
    args = protos

    sources = proto_sources
    outputs = get_path_info(protogens + protogens_cc + protogens_js, "abspath")

    if (defined(invoker.testonly)) {
      testonly = invoker.testonly
    }

    args += [
      # Wrapper should never pick a system protoc.
      # Path should be rebased because |root_build_dir| for current toolchain
      # may be different from |root_out_dir| of protoc built on host toolchain.
      "--protoc",
      "./" + rebase_path(_protoc_path, root_build_dir),
      "--proto-in-dir",
      rebase_path(proto_in_dir, root_build_dir),
    ]

    if (generate_cc) {
      args += [
        "--cc-out-dir",
        rel_cc_out_dir,
      ]
      #if (enable_kythe_annotations) {
      #  args += [ "--enable-kythe-annotation" ]
      #}
      if (defined(invoker.cc_generator_options)) {
        args += [
          "--cc-options",
          invoker.cc_generator_options,
        ]
      }
      if (defined(invoker.allow_optional) && invoker.allow_optional == true) {
        args += [ "--allow-optional" ]
      }
      if (defined(invoker.cc_include)) {
        args += [
          "--include",
          invoker.cc_include,
        ]
      }
    }

    if (generate_with_plugin) {
      args += [
        "--plugin",
        rebase_path(plugin_path, root_build_dir),
        "--plugin-out-dir",
        rel_cc_out_dir,
      ]
      if (defined(invoker.generator_plugin_options)) {
        args += [
          "--plugin-options",
          invoker.generator_plugin_options,
        ]
      }
    }

    if (generate_descriptor != "") {
      depfile =
          "$root_gen_dir/" + proto_out_dir + "/" + generate_descriptor + ".d"
      rel_depfile = rebase_path(depfile, root_build_dir)

      if (exclude_imports) {
        args += [ "--exclude-imports" ]
      }

      args += [
        "--descriptor-set-out",
        rel_descriptor_out,
        "--descriptor-set-dependency-file",
        rel_depfile,
      ]
    }

    if (defined(invoker.import_dirs)) {
      foreach(path, invoker.import_dirs) {
        args += [ "--import-dir=" + rebase_path(path, root_build_dir) ]
      }
    }

    # System protoc is not used so it's necessary to build a chromium one.
    inputs = [ _protoc_path ]
    #deps = [ _protoc_label ]
    deps = []

    if (generate_with_plugin) {
      inputs += [ plugin_path ]
      if (defined(invoker.generator_plugin_script_deps)) {
        # Additional scripts for plugin.
        inputs += invoker.generator_plugin_script_deps
      }
      if (defined(plugin_host_label)) {
        # Action depends on native generator plugin but for host toolchain only.
        deps += [ plugin_host_label ]
      }
    }

    # The deps may have steps that have to run before running protoc.
    if (defined(invoker.proto_deps)) {
      deps += invoker.proto_deps
    }
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }
  }

  if (!generate_library) {
    # If only descriptor is required, just generate a group wrapper for action output.
    link_target_type = "group"
  } else if ((defined(invoker.force_source_set) && invoker.force_source_set) ||
             (defined(invoker.component_build_force_source_set) &&
              invoker.component_build_force_source_set && is_component_build)) {
    # Option to disable building a library in component build.
    link_target_type = "source_set"
  } else {
    link_target_type = "static_library"
  }

  # Generated files may include other generated headers. These includes always
  # use relative paths starting at |cc_out_dir|.
  # However there is no necessity to add an additional directory, if all protos
  # are located in the same directory which is in the search path by default.
  config_name = "${target_name}_config"
  config(config_name) {
    include_dirs = []
    if (has_nested_dirs && generate_cc) {
      include_dirs += [ cc_out_dir ]
    }
    if (defined(invoker.import_dirs)) {
      foreach(path, invoker.import_dirs) {
        include_dirs += [ "$root_gen_dir/" + rebase_path(path, "//") ]
      }
    }
  }

  # Build generated protobuf stubs as libary or source set.
  target(link_target_type, target_name) {
    forward_variables_from(invoker,
                           [
                             "defines",
                             "testonly",
                             "visibility",
                           ])

    if (generate_library) {
      sources = get_path_info(protogens_cc, "abspath")

      if (defined(invoker.remove_configs)) {
        configs -= invoker.remove_configs
      }

      if (defined(invoker.extra_configs)) {
        configs += invoker.extra_configs
      }

      # Remove Sanitizer and coverage instrumentation for a performance boost when
      # fuzzing, since the only fuzzers that use protobuf are libprotobuf-mutator
      # based fuzzers, and they don't actually target protobuf code.
      #configs -= not_fuzzed_remove_configs
      #configs += [ "//build/config/sanitizers:not_fuzzed" ]
    }

    public_configs = [
      #"//third_party/protobuf:using_proto",
      #"//third_party/protobuf:allow_deprecated_proto_fields",
    ]
    public_deps = []

    if (generate_cc || generate_with_plugin) {
      # Not necessary if all protos are located in the same directory.
      if (has_nested_dirs || defined(invoker.import_dirs)) {
        # By default, propagate the config for |include_dirs| to dependent
        # targets, so that public imports can be resolved to corresponding
        # header files. In some cases, the embedder target handles include
        # directory propagation itself, e.g. via a common config.
        propagate_imports_configs =
            !defined(invoker.propagate_imports_configs) ||
            invoker.propagate_imports_configs
        if (propagate_imports_configs) {
          public_configs += [ ":$config_name" ]
        } else {
          # Embedder handles include directory propagation to dependents.
          configs += [ ":$config_name" ]
        }
      }

      # If using built-in cc generator, the resulting headers reference headers
      # within protobuf_lite. Hence, dependencies require those headers too.
      # If using generator plugin, extra deps should be resolved by the invoker.
      if (generate_cc) {

        if (is_win) {
          cflags = [
            # disable: C4125 decimal digit terminates octal escape sequence
            # Protoc generates such sequences frequently, there's no obvious
            # superior replacement behavior. Since this code is autogenerated,
            # the warning would never catch a legitimate bug.
            "/wd4125",
          ]
        }
      }
    }

    public_deps += [ ":$action_name" ]
    deps = []

    # This will link any libraries in the deps (the use of invoker.deps in the
    # action won't link it).
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }
    if (defined(invoker.link_deps)) {
      deps += invoker.link_deps
    }
  }
}
